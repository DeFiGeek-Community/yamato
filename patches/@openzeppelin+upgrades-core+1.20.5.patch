diff --git a/node_modules/@openzeppelin/upgrades-core/dist/deployment.js b/node_modules/@openzeppelin/upgrades-core/dist/deployment.js
index 8865cff..ff9f284 100644
--- a/node_modules/@openzeppelin/upgrades-core/dist/deployment.js
+++ b/node_modules/@openzeppelin/upgrades-core/dist/deployment.js
@@ -93,8 +93,10 @@ async function validateStoredDeployment(stored, provider, type, opts, merge) {
 async function waitAndValidateDeployment(provider, deployment, type, opts) {
     const { txHash, address } = deployment;
     // Poll for 60 seconds with a 5 second poll interval by default.
-    const pollTimeout = opts?.timeout ?? 60e3;
-    const pollInterval = opts?.pollingInterval ?? 5e3;
+    const pollTimeout = opts?.timeout ?? 360e3;
+    const pollInterval = opts?.pollingInterval ?? 10e3;
+    // const pollTimeout = opts?.timeout ?? 60e3;
+    // const pollInterval = opts?.pollingInterval ?? 5e3;
     (0, debug_1.default)('polling timeout', pollTimeout, 'polling interval', pollInterval);
     if (txHash !== undefined) {
         const startTime = Date.now();
diff --git a/node_modules/@openzeppelin/upgrades-core/dist/eip-1967.js b/node_modules/@openzeppelin/upgrades-core/dist/eip-1967.js
index 6b2623e..b8ffff1 100644
--- a/node_modules/@openzeppelin/upgrades-core/dist/eip-1967.js
+++ b/node_modules/@openzeppelin/upgrades-core/dist/eip-1967.js
@@ -18,6 +18,7 @@ async function getAdminAddress(provider, address) {
 exports.getAdminAddress = getAdminAddress;
 async function getImplementationAddress(provider, address) {
     const storage = await getStorageFallback(provider, address, toEip1967Hash('eip1967.proxy.implementation'), toFallbackEip1967Hash('org.zeppelinos.proxy.implementation'));
+    
     if (isEmptySlot(storage)) {
         throw new EIP1967ImplementationNotFound(`Contract at ${address} doesn't look like an ERC 1967 proxy with a logic contract address`);
     }
@@ -32,15 +33,36 @@ async function getBeaconAddress(provider, address) {
     return parseAddressFromStorage(storage);
 }
 exports.getBeaconAddress = getBeaconAddress;
+let waitTotal = 0.5 * 60 * 1000; // Note: many slots there.
+let checkInterval = 3 * 1000;
+let maxCount = Math.floor(waitTotal / checkInterval);
+async function waitAndExist(provider, address, slot, count){
+    if (count >= 1) {
+        console.log("eip-1967.js:L38", `${address}-proxy's impl existence check :: wait ${checkInterval/1000} sec`);
+        await new Promise(resolve => setTimeout(resolve, checkInterval))    
+    }
+    let storage = await (0, provider_1.getStorageAt)(provider, address, slot);
+    console.log("eip-1967.js:L42", storage);
+    return {
+        implementationExist: !isEmptySlot(storage),
+        storage
+    };
+}
 async function getStorageFallback(provider, address, ...slots) {
     let storage = '0x0000000000000000000000000000000000000000000000000000000000000000'; // default: empty slot
+    let result = { implementationExist: false, storage };
     for (const slot of slots) {
-        storage = await (0, provider_1.getStorageAt)(provider, address, slot);
-        if (!isEmptySlot(storage)) {
+        result = { implementationExist: false, storage };
+        let count = 0;
+        while (!result.implementationExist && count < maxCount) {
+            result = await waitAndExist(provider, address, slot, count);
+            count++;
+        }
+        if (result.implementationExist) {
             break;
         }
     }
-    return storage;
+    return result.storage;
 }
 function toFallbackEip1967Hash(label) {
     return '0x' + (0, ethereumjs_util_1.keccak256)(Buffer.from(label)).toString('hex');
